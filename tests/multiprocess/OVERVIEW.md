# CapsWriter Server 多进程升级测试方案 - 总览

## 📦 测试套件内容

```
tests/multiprocess/
├── 📄 OVERVIEW.md                    ← 你在这里！
├── 📘 README.md                      主测试文档（详细步骤）
├── 🚀 QUICKSTART.md                  快速开始指南
│
├── 🔧 核心测试文件
│   ├── test_core_multiprocess.py    多进程版 Server（测试版）
│   ├── test_concurrent_client.py    并发测试客户端
│   ├── monitor_resources.py         资源监控工具
│   └── run_test.py                  一键测试脚本
│
├── 📋 配置文件
│   ├── __init__.py                  包初始化
│   ├── requirements.txt             测试依赖
│   └── .gitignore                   Git 忽略规则
│
└── 📊 输出目录
    └── logs/                        监控日志（自动生成）
```

---

## 🎯 测试目标

验证 CapsWriter Server 支持**多文件并发转写**的可行性：

| 方面 | 验证内容 |
|------|---------|
| **功能** | 多进程能否正确处理并发任务 |
| **性能** | 并发是否真正提升吞吐量 |
| **资源** | CPU 和内存占用是否可控 |
| **稳定性** | 长时间运行是否稳定 |

---

## 🔬 测试方法

### 对比测试设计

```
┌─────────────────────────────────────┐
│  基准组（单进程）                      │
├─────────────────────────────────────┤
│  Server: 1 个识别进程                 │
│  测试: 发送 2 个音频文件               │
│  结果: 串行处理（一个接一个）           │
└─────────────────────────────────────┘
              ⬇️  对比
┌─────────────────────────────────────┐
│  实验组（多进程）                      │
├─────────────────────────────────────┤
│  Server: 2 个识别进程                 │
│  测试: 发送 2 个音频文件               │
│  结果: 并行处理（同时进行）             │
└─────────────────────────────────────┘
```

### 关键指标

1. **并发加速比** = 单进程总耗时 / 多进程总耗时
2. **内存增长比** = 多进程峰值内存 / 单进程峰值内存
3. **CPU 利用率**：观察是否有多个进程同时高 CPU

---

## 🛠️ 核心改动

### 原架构（串行）

```python
# core.py (原版)
recognize_process = Process(target=init_recognizer, ...)  # 单进程
recognize_process.start()

# server_init_recognizer.py
while True:
    task = queue_in.get()      # 逐个取任务
    result = recognize(...)    # 串行处理
    queue_out.put(result)
```

### 新架构（并行）

```python
# test_core_multiprocess.py (测试版)
for i in range(worker_processes):  # 创建多个进程
    process = Process(target=init_recognizer, ...)
    process.start()
    recognize_processes.append(process)

# server_init_recognizer.py (不变)
# 每个进程独立循环，从同一队列取任务
while True:
    task = queue_in.get()      # 多个进程竞争取任务
    result = recognize(...)    # 并行处理
    queue_out.put(result)
```

**关键特性**：
- ✅ 最小改动：只修改进程创建逻辑
- ✅ 识别逻辑不变：每个进程独立运行原有代码
- ✅ 任务分配自动：通过队列竞争实现负载均衡

---

## 📊 预期测试结果

### 理想情况（假设每个文件处理 12 秒）

| 指标 | 单进程 | 多进程（2个） | 变化 |
|------|--------|-------------|------|
| 文件1处理 | 12s | 12s | - |
| 文件2处理 | 12s | 12s | - |
| **总耗时** | **24s** | **~13s** | ⚡ **1.85x** |
| 峰值内存 | 2 GB | ~3.7 GB | 📈 **1.85x** |
| 进程数 | 2 个 | 4 个 | +2 |

### 成功标准

| 检查项 | 标准 | 说明 |
|--------|------|------|
| ✅ 功能正确性 | 所有文件成功转录 | 无错误、无崩溃 |
| ✅ 性能提升 | 加速比 ≥ 1.5x | 有明显提速 |
| ✅ 资源可控 | 内存增长比 ≤ 2.5x | 不会过度占用内存 |
| ✅ 内存限制 | 峰值内存 ≤ 6 GB | 16GB 机器可运行 |

---

## 🚀 快速开始

### 最简单的方法

```bash
# 1. 安装测试依赖
pip install psutil

# 2. 运行一键测试脚本
python tests/multiprocess/run_test.py
```

脚本会引导你完成全部测试步骤！

### 手动测试（3 个终端）

```bash
# 终端 1：启动多进程 Server
python tests/multiprocess/test_core_multiprocess.py

# 终端 2：启动资源监控
python tests/multiprocess/monitor_resources.py

# 终端 3：运行测试客户端
python tests/multiprocess/test_concurrent_client.py
```

---

## 📖 文档导航

| 文档 | 适合人群 | 内容 |
|------|---------|------|
| **[QUICKSTART.md](QUICKSTART.md)** | 想快速试用 | 5分钟快速测试指南 |
| **[README.md](README.md)** | 想详细了解 | 完整测试步骤、故障排查 |
| **OVERVIEW.md** | 想了解全貌 | 本文档，测试方案总览 |

---

## 🔍 技术亮点

### 1. 最小化改动原则

- ✅ **不修改**识别逻辑（`server_recognize.py`）
- ✅ **不修改**WebSocket 处理（`server_ws_recv.py`）
- ✅ **只修改**进程创建（`core.py` 约 50 行代码）

### 2. 自然的任务分配

利用 Python `Queue` 的线程安全特性：
- 多个进程从同一队列取任务
- 先空闲的进程先取到任务
- 自动实现负载均衡

### 3. 独立的测试环境

- 测试代码在 `tests/` 目录，不影响主代码
- 可以随时切换单进程/多进程测试
- 验证通过后再合并到主代码

---

## ⚠️ 已知限制

### 1. 内存占用线性增长

- 2 个进程 ≈ 3.5-4 GB
- 3 个进程 ≈ 5-6 GB
- 4 个进程 ≈ 7-8 GB

**原因**：ONNX 模型在每个进程中独立加载，无法共享。

### 2. 适用场景

适合：
- ✅ 批量转写多个音频文件
- ✅ 服务器端部署（16GB+ 内存）
- ✅ 对吞吐量有要求的场景

不适合：
- ❌ 个人电脑低配置（< 8GB 内存）
- ❌ 只转写单个文件
- ❌ 追求极致内存优化

### 3. 效率递减

| 进程数 | 理论加速 | 实际加速 | 效率 |
|--------|---------|---------|------|
| 1 | 1.0x | 1.0x | 100% |
| 2 | 2.0x | ~1.8x | 90% |
| 3 | 3.0x | ~2.4x | 80% |
| 4 | 4.0x | ~3.0x | 75% |

**原因**：队列竞争、系统调度开销、I/O 瓶颈。

---

## 🎓 技术细节

### 进程间通信

```
┌─────────────────────────────────────────┐
│  主进程（asyncio 事件循环）                │
├─────────────────────────────────────────┤
│  ├─ WebSocket 服务器                     │
│  ├─ queue_in (任务队列)  ←────┐          │
│  └─ queue_out (结果队列) ←──┐ │          │
└───────────────────────┬─────┼─┼──────────┘
                        │     │ │
        ┌───────────────┼─────┘ │
        │               │       │
  ┌─────▼─────┐   ┌────▼──────┐│
  │ 识别进程 1  │   │ 识别进程 2 ││
  ├───────────┤   ├───────────┤│
  │ 加载模型   │   │ 加载模型   ││
  │ 识别循环   │   │ 识别循环   ││
  └───────────┘   └───────────┘│
        │               │       │
        └───────────────┴───────┘
           并行识别任务
```

### 任务竞争机制

```python
# queue_in 是 multiprocessing.Queue，线程安全
queue_in = Queue()

# 进程 1
while True:
    task = queue_in.get()  # 阻塞等待，先到先得
    result = recognize(task)
    queue_out.put(result)

# 进程 2
while True:
    task = queue_in.get()  # 同时等待同一队列
    result = recognize(task)
    queue_out.put(result)
```

---

## 📈 后续优化方向

### 短期（已实现）

- [x] 基础多进程架构
- [x] 并发测试套件
- [x] 资源监控工具

### 中期（可选）

- [ ] 动态进程数调整（根据系统资源）
- [ ] 任务优先级队列（麦克风 > 文件）
- [ ] 进程池热更新（运行时调整）

### 长期（探索）

- [ ] 模型共享内存（降低内存占用）
- [ ] GPU 加速支持
- [ ] 分布式部署（多机协作）

---

## 💬 反馈与贡献

如有问题或建议：
- 📝 提交 Issue
- 💡 参与讨论
- 🤝 贡献代码

---

## 📄 许可证

本测试方案遵循 CapsWriter-Offline 项目主许可证。

---

**祝测试顺利！** 🚀
