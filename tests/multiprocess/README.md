# CapsWriter Server 多进程升级测试方案

## 📋 测试目标

本测试方案旨在验证 CapsWriter Server 多进程架构的可行性，主要验证以下方面：

1. **功能验证**：多进程架构能否正常处理并发任务
2. **性能评估**：并发处理是否能提升吞吐量
3. **资源监控**：CPU 和内存占用情况
4. **稳定性测试**：长时间运行是否稳定

---

## 📁 测试文件结构

```
tests/multiprocess/
├── README.md                      # 本文档
├── test_core_multiprocess.py      # 多进程版本 Server 核心
├── test_concurrent_client.py      # 并发测试客户端
├── monitor_resources.py           # 资源监控工具
└── logs/                          # 监控日志目录（自动创建）
```

---

## 🔧 环境准备

### 1. 安装依赖

确保已安装所有依赖：

```bash
# 安装服务端依赖
pip install -r requirements-server.txt

# 安装额外的测试依赖
pip install psutil
```

### 2. 准备测试文件

测试使用 `ref_codes/samples/` 目录下的音频文件：

```bash
# 查看测试文件
ls -lh ref_codes/samples/

# 预期输出：
# 01.mp3  (约 15MB)
# 02.mp3  (约 14MB)
```

### 3. 配置检查

检查 `src/capswriter/config.py` 中的配置：

```python
class ServerConfig:
    addr = '0.0.0.0'
    port = '6016'
    model_type = 'firered'  # 或 'paraformer', 'sensevoice'
```

---

## 🚀 测试步骤

### 阶段一：单进程基准测试（对照组）

#### 1.1 启动原版 Server

```bash
# 在终端 1 中运行
python -m capswriter.server.core
```

等待模型加载完成，看到 "开始服务" 提示。

#### 1.2 运行资源监控

```bash
# 在终端 2 中运行
python tests/multiprocess/monitor_resources.py
```

保持监控运行，观察资源占用基线。

#### 1.3 运行基准测试

```bash
# 在终端 3 中运行
python tests/multiprocess/test_concurrent_client.py
```

**预期结果**：
- 两个文件**串行处理**（一个接一个）
- 总耗时 ≈ 文件1处理时间 + 文件2处理时间
- 内存占用：约 **1.5-2.5 GB**
- CPU 占用：单个识别进程 **50-80%**

#### 1.4 记录基准数据

在测试完成后，记录以下数据：

| 指标 | 数值 |
|------|------|
| 文件1处理时长 | ____ s |
| 文件2处理时长 | ____ s |
| 总测试耗时 | ____ s |
| 并发加速比 | ____ x |
| 峰值内存占用 | ____ MB |
| 平均CPU占用 | ____ % |

**停止所有进程**，准备下一阶段测试。

---

### 阶段二：多进程并发测试（实验组）

#### 2.1 启动多进程版 Server

```bash
# 在终端 1 中运行
python tests/multiprocess/test_core_multiprocess.py
```

**观察启动日志**：

```
🔧 多进程模式：2 个识别进程

正在启动 2 个识别进程...
  ✅ 进程 1 初始化完成
  ✅ 进程 2 初始化完成

═══════════════════════════════════════
所有识别进程已就绪，开始服务
═══════════════════════════════════════
```

#### 2.2 运行资源监控

```bash
# 在终端 2 中运行
python tests/multiprocess/monitor_resources.py --interval 0.5
```

**关键观察指标**：

- **进程总数**：应该看到 1 个主进程 + 2 个识别子进程 = 3 个进程
- **总内存占用**：预期 **3-6 GB**（取决于模型）
- **CPU 占用**：并发时应该看到多个进程同时高 CPU

#### 2.3 运行并发测试

```bash
# 在终端 3 中运行
python tests/multiprocess/test_concurrent_client.py
```

**预期结果**：

- 两个文件**并行处理**（同时进行）
- 总耗时 ≈ max(文件1处理时间, 文件2处理时间)
- 并发加速比：**1.5x - 2.0x**
- 内存占用：约 **3.5-5.5 GB**（是单进程的 1.8-2倍）
- CPU 占用：多个识别进程同时高 CPU

#### 2.4 记录测试数据

| 指标 | 单进程（基准） | 多进程（实验） | 变化 |
|------|--------------|--------------|------|
| 文件1处理时长 | ____ s | ____ s | ____ |
| 文件2处理时长 | ____ s | ____ s | ____ |
| 总测试耗时 | ____ s | ____ s | ____ |
| 并发加速比 | 1.0x | ____ x | ____ |
| 峰值内存占用 | ____ MB | ____ MB | ____ |
| 平均CPU占用 | ____ % | ____ % | ____ |

---

## 📊 结果分析指标

### 1. 功能正确性

- [ ] 所有文件都成功转录
- [ ] 识别结果文本正确
- [ ] 没有出现崩溃或错误

### 2. 性能提升

计算并发加速比：

```
并发加速比 = (单进程总耗时) / (多进程总耗时)
```

**判断标准**：

| 加速比 | 评价 | 说明 |
|--------|------|------|
| ≥ 1.8x | ✅ 优秀 | 并发效果显著 |
| 1.5-1.8x | ✅ 良好 | 有明显提升 |
| 1.2-1.5x | ⚠️ 一般 | 有轻微提升 |
| < 1.2x | ❌ 不佳 | 并发收益不明显 |

### 3. 资源开销

计算内存增长比：

```
内存增长比 = (多进程内存) / (单进程内存)
```

**判断标准**：

| 增长比 | 评价 | 说明 |
|--------|------|------|
| 1.8-2.2x | ✅ 理想 | 接近理论值（2倍） |
| 2.2-2.5x | ⚠️ 可接受 | 略高但可用 |
| > 2.5x | ❌ 过高 | 有内存泄漏风险 |

### 4. CPU 利用率

观察监控工具中的 CPU 占用：

- **单进程**：应该只有 1 个进程 CPU 占用高（50-80%）
- **多进程**：应该有 2 个进程同时 CPU 占用高

---

## 🎯 成功标准

多进程方案被认为**可行**，需要满足：

1. ✅ **功能正确**：所有测试文件都能正确转录
2. ✅ **性能提升**：并发加速比 ≥ 1.5x
3. ✅ **资源可控**：
   - 内存增长比 ≤ 2.5x
   - 峰值内存 ≤ 8GB（假设目标机器 16GB）
4. ✅ **稳定运行**：无崩溃、无内存泄漏

---

## 🔍 故障排查

### 问题 1：Server 启动失败

**现象**：进程初始化失败

**可能原因**：
- 模型文件缺失或损坏
- 依赖包版本不兼容

**解决方法**：
```bash
# 检查模型
python -m capswriter.server.utils.server_check_model

# 重新安装依赖
pip install --upgrade sherpa-onnx funasr-onnx
```

### 问题 2：客户端连接失败

**现象**：`✗ 无法连接到服务器`

**可能原因**：
- Server 未启动
- 端口被占用
- 防火墙阻止

**解决方法**：
```bash
# 检查端口占用
netstat -ano | findstr 6016  # Windows
lsof -i :6016               # Linux/Mac

# 检查防火墙
# 临时关闭防火墙测试
```

### 问题 3：内存占用过高

**现象**：内存增长比 > 3.0x

**可能原因**：
- 任务结果未及时清理
- 音频缓冲区泄漏

**解决方法**：
- 检查 `server_recognize.py:98` 的 `results.pop()` 是否正确执行
- 增加日志确认任务完成后的清理逻辑

### 问题 4：并发加速比 < 1.2x

**现象**：多进程没有明显提速

**可能原因**：
- 队列成为瓶颈（所有进程竞争同一队列）
- 磁盘 I/O 瓶颈
- GIL 争用（不太可能，因为识别在 C++ 层）

**解决方法**：
- 检查监控工具，确认是否有进程空闲
- 增加更多测试文件（3-4个），看加速比是否提升
- 考虑使用多队列架构

---

## 📝 测试报告模板

```markdown
# 多进程测试报告

**测试日期**：2025-XX-XX
**测试人员**：[你的名字]
**测试环境**：
- 操作系统：Windows 10 / Ubuntu 20.04 / macOS
- CPU：[型号]，[核心数]
- 内存：[容量] GB
- Python 版本：[版本]

## 测试结果

### 基准测试（单进程）
- 文件1处理时长：X.XX s
- 文件2处理时长：X.XX s
- 总测试耗时：X.XX s
- 峰值内存：XXXX MB
- 平均CPU：XX%

### 并发测试（2进程）
- 文件1处理时长：X.XX s
- 文件2处理时长：X.XX s
- 总测试耗时：X.XX s
- 并发加速比：X.XX x
- 峰值内存：XXXX MB（增长比 X.XX x）
- 平均CPU：XX%

## 结论

- [ ] 功能正确性：通过/失败
- [ ] 性能提升：优秀/良好/一般/不佳
- [ ] 资源开销：理想/可接受/过高
- [ ] 稳定性：稳定/不稳定

**总体评价**：多进程方案 [可行/需要优化/不可行]

**建议**：
1. ...
2. ...
```

---

## 🔄 后续优化建议

如果测试通过，可以考虑以下优化：

### 1. 动态进程数调整

```python
class MultiProcessConfig:
    worker_processes = auto_detect_workers()  # 根据系统资源自动检测
```

### 2. 任务优先级队列

- 麦克风实时任务 > 文件转写任务
- 小文件 > 大文件

### 3. 资源监控集成

将监控工具集成到 Server，实时调整进程数。

### 4. 进程池热更新

支持运行时修改进程数，无需重启 Server。

---

## 📞 联系与反馈

如有问题或建议，请：
- 提交 Issue：https://github.com/HaujetZhao/CapsWriter-Offline/issues
- 邮件联系：[项目维护者邮箱]

---

## 📄 许可证

本测试方案遵循项目主许可证。
